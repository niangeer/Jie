继承（面向对象三大特性：封装、继承、多态）
    1，封装的本质是一种更好的管理
	    相对C语言面向过程，C++把数据和方法都放到类中进行管理，再通过访问限定符进行限制
		
		继承：从类设计角度，避免重复定义数据和方法，进行类角度的复用
			
	2，继承的概念及定义
	    1，概念
	        继承机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，
	        增加功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。
		    以前我们接触的复用都是函数复用，继承是类设计层次的复用。
			  
	    2，定义
		    a，定义格式
		       class Student : public    Person
			         派生类   继承方式    基类
						 
			b，继承关系和访问限定符
			    (1)基类private成员派生类中无论以什么方式继承都是不可见的。
				   不可见是指基类的私有成员还是被继承到了派生类对象中，但是派生类对象不管是在类里还是类外都无法访问它
					  
				(2)设权限为 public > protected > private
				    那么基类的其他成员在子类的访问方式 == Min(成员在基类的访问限定符，继承方式)
						
				(3)使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public
					
	3，基类和派生类对象赋值转换(public继承才可以， protected、private继承方式不可以)
	    1，派生类对象 可以赋值给 基类的对象 / 基类的指针 / 基类的引用。
		   这里有个形象的说法叫切片或者切割。寓意把派生类中父类那部分切来赋值过去
			  
		2，基类对象不能赋值给派生类对象
			
			3，基类的指针可以通过强制类型转换赋值给派生类的指针。但是必须是基类的指针是指向派生类对象时才是安全的。
		   这里基类如果是多态类型，可以使用RTTI(Run-Time Type Information)的dynamic_cast 来进行识别后进行安全转换
			   
	4，继承中的作用域
	    1，在继承体系中基类和派生类都有独立的作用域
		
		2，子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏，也叫重定义
		    （在子类成员函数中，可以使用 基类::基类成员 显示访问）
				
	    3，需要注意的是如果是成员函数的隐藏，只需要函数名相同就构成隐藏
			
		4，注意在实际中在继承体系里面最好不要定义同名的成员。
			
    5，派生类默认成员函数
	    1，派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。如果基类没有默认的构造函
		   数，则必须在派生类构造函数的初始化列表阶段显示调用。
			   
		2，派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。
			
		3，派生类的operator=必须要调用基类的operator=完成基类的复制。
			
		4，派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。
		   因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序。
			   
		5，派生类对象初始化先调用基类构造再调派生类构造。
			
		6，派生类对象析构清理先调用派生类析构再调基类的析构。
			
	6，继承与友元
	    友元关系不能继承，也就是说基类友元关系不继承给派生类
			
	7，继承与静态成员 
	    基类定义了static静态成员，则整个继承体系里面只有一个这样的成员。
		无论派生出多少个子类，都只有一个static成员实例 。
			
	8，菱形继承及菱形虚拟继承
	    1，继承的种类
		    单继承：一个子类只有一个直接父类时称这个继承关系为单继承
			多继承：一个子类有两个或以上直接父类时称这个继承关系为多继承（多继承大小 = 派生类大小 + 基类大小；需要内存对齐）
			菱形继承：菱形继承是多继承的一种特殊情况。
				
			缺点：菱形继承有数据冗余和二义性的问题
			解决办法：使用虚拟继承
				
		2，虚拟继承原理
		    使用虚拟继承，派生类中只有一份公共的虚基类成员。    （具体实例分析看项目继承）
		    虚拟继承里会存有虚基表指针，虚基表指针指向虚基表，里面存储的是当前位置距离虚基类对象的偏移量
				
			a，使用虚拟继承后派生类的大小 = 基类大小 + 自身大小 + 绝对基类大小(公共的虚基类成员)  需要内存对齐
			b，入栈顺序
			    例：class D : public B, public C 
				    B先入栈，然后C，然后D，最后跟公共的虚基类成员
			c，虚基表指针指向的第一个地址是预留给虚表用的，第二个才是虚基表
				
	9，继承的总结和反思
	    1，很多人说C++语法复杂，其实多继承就是一个体现。有了多继承，就存在菱形继承，有了菱形继承就有菱形虚拟继承，
		   底层实现就很复杂。一般不建议设计出多继承，一定不要设计出菱形继承。否则在复杂度及性能上都有问题。
			
		2，多继承可以认为是C++的缺陷之一，很多后来的OO语言都没有多继承，如Java。
			
	    3，继承和组合
		    a，继承是is_a的关系。 派生类和基类间的依赖关系很强，耦合度高。属于是白箱复用
			b，组合是has_a的关系。 组合类之间没有很强的依赖关系，耦合度低。属于是黑箱复用
			c，建议优先使用对象组合而不是类继承
			   
多态
    1，多态的概念：通俗来说，就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。
	   静态多态：在程序编译期间确定了程序的行为，称为静态多态，比如：函数重载
	   动态多态：虚函数重写以后，父类指针或引用调用重写虚函数，指向谁调用的就是谁的虚函数。例如虚函数多态
		
	2，多态的定义及实现
	    a，多态的构成条件
	        (1)必须通过基类的指针或者引用调用虚函数
		    (2)被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写
			   
	    b，虚函数：即被virtual修饰的类成员函数称为虚函数。  注意：虚函数需要是类成员函数
			
		c，虚函数的重写（覆盖）
		    派生类中有一个跟基类完全相同的虚函数(即派生类虚函数与基类虚函数的返回值类
			型、函数名字、参数列表完全相同)，称子类的虚函数重写了基类的虚函数。
				
		注意：虚函数重写的两个例外
		    1，协变(基类与派生类虚函数返回值类型不同)
			    派生类重写基类虚函数时，与基类虚函数返回值类型不同。即基类虚函数返回基类对象的指针或者引用，
				派生类虚函数返回派生类对象的指针或者引用时，称为协变。
					
			2，析构函数的重写(基类与派生类析构函数的名字不同)
			    如果基类的析构函数为虚函数，此时派生类析构函数只要定义，无论是否加virtual关键字，都与基类的
				析构函数构成重写，虽然基类与派生类析构函数名字不同。虽然函数名不相同，看起来违背了重写的规则，
			    其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor。
		    
	3，final修饰类：表示类无法被继承
	        修饰虚函数：表示该虚函数无法被重写
				
	   override: 检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错
	   
	4，重载  ：两个函数在同一作用域，函数名相同，参数不同
	   重写  ：函数作用域一个在基类一个在派生类，函数名、返回值、参数都相同(协变除外)，且两个函数都为虚函数
	   重定义：函数作用域一个在基类一个在派生类，函数名相同，两个基类和派生类的同名函数不构成重写就是重定义
	   
	5，抽象类
	    a，纯虚函数：在虚函数的后面写上 =0（后面不需要{}）;
		   例：virtual void Func() = 0;
			  
		b，包含纯虚函数的类叫做抽象类（也叫接口类），抽象类不能实例化出对象。
		   派生类继承后也不能实例化出对象，只有重写纯虚函数，派生类才能实例化出对象。
		   纯虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承。
			   
		c，接口继承和实现继承
		   普通函数的继承是一种实现继承，派生类继承了基类函数，可以使用函数，继承的是函数的实现。
		   虚函数的继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口。
		   所以如果不实现多态，不要把函数定义成虚函数。
			   
	6，多态原理
	    a，虚函数表（虚表）
		   一个含有虚函数的类中都至少都有一个虚函数表指针，因为虚函数的地址要被放到虚函数表中，虚函数表也简称虚表
			   
		   例：Person b; Student d;
		   (1)派生类对象d中也有一个虚表指针，d对象由两部分构成，一部分是父类继承下来的成员，
		      虚表指针就是存在此部分的，另一部分是自己的成员。
				  
		   (2)基类b对象和派生类d对象虚表是不一样的，而且我们发现Func1完成了重写，d与b中Func1的地址不一样
		      所以d的虚表中存的是重写的Student::Func1，所以虚函数的重写也叫作覆盖，
			  覆盖就是指虚表中虚函数的覆盖。重写是语法的叫法，覆盖是原理层的叫法。
				  
		   (3)另外Func2继承下来后是虚函数，所以放进了虚表，Func3也继承下来了，但是不是虚函数，所以不会放进虚表
			   
		   (4)虚函数表本质是一个存放虚函数指针的指针数组，这个数组最后面放了一个nullptr表示结尾。
			   
		   (5)总结一下派生类的虚表生成：
		         <1>先将基类中的虚表内容拷贝一份到派生类虚表中
				 <2>如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数
				 <3>派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。
					 
		   (6)虚函数存在哪的？
		      虚函数和普通函数一样的，都是存在代码段的，只是他的指针又存到了虚表中。
			  对象中存的不是虚表，存的是虚表指针。虚表也存于代码段中
				  
			  同一类型对象的虚表是否是同一个？
			  是同一个
				  
			  虚表是什么时候生成的？
			  编译时就生成了
				  
		b，多态原理
		   (1)rp是指向p对象时，rp->BuyTicket在p的虚表中找到虚函数是Person::BuyTicket。
			   
		   (2)rp是指向s对象时，rp->BuyTicket在s的虚表中找到虚函数是Student::BuyTicket。
			   
		   (3)这样就实现出了不同对象去完成同一行为时，展现出不同的形态。
		      所以要达到多态，有两个条件，一个是虚函数覆盖，一个是对象的指针或引用调用虚函数
				  
		   (4)为什么只能使用引用或指针去调虚函数？
		      因为对象的类型在编译器就确定了，指针或引用是在运行期根据他们绑定的具体对象确定
			   
		   (5)满足多态以后的函数调用，不是在编译时确定的，是运行起来以后到对象的虚表中去找的。
		      不满足多态的函数调用是编译时确认好的。(形参采用传值方式时，就是编译时就确认好的)