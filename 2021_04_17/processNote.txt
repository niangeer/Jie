一，冯诺依曼体系
    1，体系结构分为硬件架构与操作系统
	    硬件架构：输入、输出、存储器（内存）、CPU（运算器、控制器）
		操作系统
		
	2，硬件
	    a，内存不属于输入输出，特性为掉电易失，可认为是外设与CPU的缓存，它是计算机数据的核心
		b，存储分级：离CPU越近，存储效率越高，单价成本越高，且容量一般越小
		c，CPU为什么要通过内存与外设进行交互？
		    因为CPU效率与外设效率差太多，如果与外设直接进行交互会造成效率的降低，
			内存可进行预加载、预写入，能够提高效率
		
	3，操作系统
	    a，是什么？
		     是一款搞“管理”的软件，管理软硬件
			 硬件方面：冯诺依曼结构中的所有设备
			 软件方面：文件管理，进程管理，内存管理，驱动管理
			 
		b，怎么管理？
		     先描述，再组织
		c，为什么要管理
	         管理好软硬件为用户程序提供良好的执行环境
			 
	补充：1，缓存是快的设备给慢的设备做缓存
          2，我们现在的计算机是出于考虑成本和效率的结果，用小成本使用上效率较高的计算机，提升性价比
		  
二，系统调用和库函数概念
    1，系统调用：
	       在开发角度，操作系统对外会表现为一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分
           由操作系统提供的接口叫做系统调用
		   
	2，库函数
	       系统调用在使用上，功能比较基础，对用户的要求相对也比较高，有开发者对部分系统调用
           进行适度封装，从而形成库。库更有利于更上层用户或者开发者进行二次开发
		   
三，进程
    1，是什么？
	    可执行程序被加载进内存，变成了进程。由可执行程序与管理进程所需要的数据结构（task_struct、mm_struck）构成
	
	2，如何管理？
	    如何新建？如何调度？如何释放？如何进行其他管理？
		
	3，为什么要对进程进行管理？
	    任务需要被计算机完成，任务可能存在多个，所以有了管理的需求，先描述，再组织
		
	4，查看进程：
	    1，通过/proc  
		2，ps (ps aux | grep "mytest"  ps axj  ps -al)
		3，top
		
	补充：bash 运行原理：
	          bash：命令行解释器
		  通常是如何进行解释的呢？
		      通过创建子进程，让子进程去完成对应的任务
			  
		每一个进程都有它的时间片，长短是不固定的，由调度器去动态计算的
		
四，PCB
    1，task_struct是Linux内核的一种数据结构，它会被装载到RAM(内存)里并且包含着进程的信息
	2，内容分类
	    a，标识符：pid , ppid 
		    gitpid()，gitppid()
		
		b，状态: 任务状态(r,s,t,d,x,z)，退出代码，退出信号
		    R:运行状态（不一定在CPU上面跑，有可能在运行队列中）
			S：浅睡眠状态（可中断）
			T:停止状态
			D：深睡眠状态（不可中断）
			X:死亡状态
			Z：僵尸状态
			
	3，僵尸进程
		a，形成原因
		    父进程还存在且子进程已退出。并且父进程未读取子进程的退出状态
			
		b，为什么要存在Z进程
		    为了让父进程有时间去读取子进程的退出状态，Z状态被读取完毕后就会变为X状态，
			进而进程的PCB信息才会被操作系统释放掉
			
		c，危害
		    会造成内存资源浪费，可能造成内存泄漏，所以一定要用wait()系统调用
			
	   孤儿进程
	    a，形成原因
		    父进程退出，子进程还在运行
		
		b，孤儿进程会被1号进程领养，由1号进程进行资源回收
		
	4，程序计数器
	    a，程序计数器是用于存放下一条指令所在单元的地址的地方。
		b，当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器中，
		   此过程称为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。
		   此后经过分析指令，执行指令。完成第一条指令的执行，而后根据PC取出第二条指令的地址，
		   如此循环，执行每一条指令。
		   
	5，上下文数据
	    a，CPU在运行进程时会产生各种临时数据，这些数据叫做当前进程的上下文数据
		b，当时间片到或者有更高优先级使得进程要发生切换，切换时要进行上下文保护，
		    进程重新加载至CPU上运行时要进行上下文恢复
		
	4，fork
	    1，如何理解进程创建？
		    系统多了一个进程就要多一组管理进程的数据结构与对应的代码和数据
			
		2，为什么会有两个返回值？
		    父进程执行创建子进程的逻辑形成子进程，在执行return 之前创建好了子进程，
			父子进程之间代码共享，数据私有（表现出了进程的独立性）
			然后return是条语句，所以父子进程都要执行，又因数据私有所以有两个返回值
		
	5，优先级: 相对于其他进程的优先级
	    1，是什么？
		    使用“事务”的先后顺序
		
		2，为什么要有？
		    需要管理的对象具有多个时，需要优先级，可以改善系统性能
			
		3，怎么办？
		    决定了哪个进程优先使用某种资源（CPU、外设IO）
			
		4，查看系统进程（ps -l）
		    UID : 代表执行者的身份
			PRI ：代表这个进程可被执行的优先级，其值越小越早被执行
			NI ：代表这个进程的nice值
			
		5，NI
		    a，nice值：进程优先级的修正数值（-20~19）
			b，PRI(new)=PRI(old)+nice
			c，进入top后按“r”–>输入进程PID–>输入nice值
			
	6，补充概念
	    1，竞争性：
		    进程数多于CPU数，进程间便具有竞争属性，为了高效完成任务，更合理竞争相关资源，便具有了优先级
			
		2，独立性: 
		    多进程运行，需要独享各种资源，多进程运行期间互不干扰
			
		3，并行
		    多个进程分别在多个CPU下同时运行，叫做并行
			
		4，并发：
		    多个进程基于时间片轮转使其看起来在同时推进的状态叫做并发
			
		5，进程在时间片内，不可被抢占，为不可抢占式调度；
		   若可被抢占则为抢占式调度
		   
五，环境变量
	1，是什么？
	    系统中的某些具有一定全局属性的变量，通常是为了满足某些系统需求
		全局属性体现在可以被子进程继承下去
			
	2，为什么？
	    为了方便用户、开发者以及系统，进行某种最简单化的查找、定位、确认等问题
			
	3，环境变量是变量，具有变量名与内容
	    PATH : 指定命令的搜索路径
		HOME : 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录)
		SHELL : 当前Shell,它的值通常是/bin/bash。
			
		查看环境变量：echo $PATH
		定义环境变量：export PATH=$PATH:/hello程序所在路径
		    在命令行中定义为临时性，永久性需要去usr/目录下
		
	4，env: 显示所有环境变量
	   unset: 清除环境变量
	   set: 显示本地定义的shell变量和环境变量
		   
	5，main函数参数:   main(int argc, char* argv[], char* env[])
	    1，int argc:命令行参数个数
		2，char* argv[]:命令行参数（在C/C++中，argv[0]为可执行程序本身）
		3，char* env[]:环境变量
		    getenv:获取环境变量，用法 getenv("PATH")
			   
		例：./mytest -a -b        其中./mytest为argv[0]算第一个命令行参数


六，进程地址空间
    1，为什么要有地址空间？
        a，为了能够让地址信息以连续的形式暴露给用户
        b，保护物理内存

    2，什么是地址空间？
        地址空间本质是用来描述进程所占用资源的一张表，其在操作系统内核当中就是一个数据结构（mm_struct），
        这个数据结构将地址空间划分成若干种区域与物理内存一一对应
                
    3，怎么工作？
        地址空间上所呈现暴露给用户的地址都是虚拟地址，实际当进程访问虚拟地址空间上的地址时，
        都是要通过页表进行映射转换到物理内存，然后拿到对应的代码和数据
                                
    4，申请空间的本质是什么？
        申请空间的本质是向内存索要空间，得到物理地址，然后在特定区域申请没有被使用的虚拟地址，
        建立映射关系，再返回虚拟地址即可
                                                
七，进程创建
    1，pid_t fork(void);  返回值:父进程返回子进程id，子进程返回0，fork失败返回-1
        
    2，进程调用fork，当控制转移到内核中的fork代码后，内核需要做：
         (1)分配新的内存块和内核数据结构给子进程
                   
         (2)将父进程部分数据结构内容拷贝至子进程（pcb、虚拟地址、页表等父子进程大部分一样，PID、兄弟关系等不一样）
                           
         (3)添加子进程到系统进程列表当中
                                   
         (4)fork返回，开始调度器调度

    3，fork之前父进程独立执行，fork之后，父子两个执行流分别执行
       谁先执行由调度器决定
           
    4，写时拷贝
         (1)通常，父子代码共享，父子进程在不写入数据时，数据也是共享的
                     
         (2)当任意一方试图写入，便以写时拷贝的方式各自一份副本    
                            
    5，常规用法
         (1)父子进程同时执行不同的代码段
            例如:父进程等待客户端请求，生成子进程来处理请求
                                                  
         (2)一个进程要执行一个不同的程序
            例如:子进程从fork返回后，调用exec函数
                                                                   
    6，fork调用失败的原因
         (1)系统中有太多的进程
         (2)实际用户的进程数超过了限制
                                                                                   
    补充：
      写时拷贝：在数据第一次写入到某个存储位置时，首先将原有内容拷贝一份至另一存储位置，然后再将要写入的数据将其覆盖
               （写多少拷多少）
                                                                                                                   
      父子进程全部代码共享，但是因为拷贝了程序计数器，所以子进程从自身创建好后的下一条指令开始执行

八，进程终止（释放资源，保留了PCB中的一些数据供父进程读取）
    1，程序退出的三种情况
       a，代码运行完毕，结果正确
       b，代码运行完毕，结果不正确
       c，代码异常终止 （被操作系统进行终止）
                            
      其中a、b场景用退出码进行标识，c场景使用wait
      进程正常终止可以通过 echo $? 查看进程退出码
                                                                                                                          
    2，进程常见退出方法
       a，return :叫做终止函数（main return，代表进程退出）
              
       b，_exit:系统接口，终止整个进程，任何地方调用，都会终止
                      
       c，exit:库函数，调用了_exit
                              
       exit 与 _exit 的区别：exit 会多做以下几种
           (1)执行用户通过 atexit或on_exit定义的清理函数
                                                
           (2)关闭所有打开的流，所有的缓存数据均被写入
                                                            
           (3)调用_exit

九，进程等待
   1，进程等待必要性
       a，子进程退出，父进程如果不管不顾，会造成僵尸进程，进而造成内存泄漏（kill -9 无法终止Z状态）
              
       b，父进程需要知道子进程的任务完成的如何。
          如，子进程运行完成，结果对还是不对，或者是否正常退出
                               
       c，父进程通过进程等待的方式，回收子进程资源，获取子进程退出信息
       
   2，进程等待的方法
       方法一:wait
       pid_t wait(int* status);  //status是一个整型指针，做输出型参数
                  
       返回值：成功返回被等待进程pid，失败返回-1（不存在子进程的情况）
       参数：输出型参数，获取子进程退出状态,不关心则可以设置成为NULL
                                      
       方法二：waitpid
       pid_t waitpid(pid_t pid, int* status, int options);
                   
       返回值：成功返回被等待进程pid，失败返回-1。
       参数：
           pid: 
              (1)Pid=-1,等待任一个子进程
              (2)Pid>0.等待其进程ID与pid相等的子进程
                                     
           status:
              (1)WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）
              (2)WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）
                                                                       
           options:
              (1)0 : 阻塞等待
              (2)WNOHANG: 若pid指定的子进程没有结束，则waitpid()函数返回值为0，不予以等待。
                          若正常结束，则返回该子进程的ID（非阻塞等待）
          
    3，获取子进程status
        a，该参数是一个输出型参数，由操作系统填充
        b，如果传递NULL，表示不关心子进程的退出状态信息，否则，操作系统会根据该参数，将子进程的退出信息反馈给父进程
        c，status可以当作位图来看待。（只看前16个bit）
           (1)正常终止：前八个Bit为0，后八个表示进程状态
           (2)异常退出（被信号所杀）：前7bit代表终止信号，第8bit代表core dump标志，后面8个bit 未使用 

    补充： wait(int* status) == waitpid(-1, int* status, 0)   
                                                     
           进程出现异常会转变成操作系统对该进程发送信号。 信号列表: kill -l  

十，进程程序替换
    1，替换原理
        a，进程调用一种exec函数时,该进程的用户空间代码和数据完全被新程序替换,从新程序的启动例程开始执行
        b，调用exec并不创建新进程,所以调用exec前后该进程的id并未改变

    2，替换函数
        (1)execl   : execl("/usr/bin/ls","ls", "-a", "-l", NULL);
        (2)execlp  : execlp("ls", "ls", "-a", "-l", NULL);
        (3)execv
        (4)execvp
        (5)execle
        (6)execve
        函数解释：
            a，如果调用成功则加载新的程序从启动代码开始执行,不再返回
            b，调用出错则返回-1
            c，所以exec函数只有出错的返回值而没有成功的返回值
            d， l:list   p:PATH    v:vector  e:env
                                                            
十一，基础IO  
    1，open
       int open(const char *pathname, int flags);   ||   int open(const char *pathname, int flags, mode_t mode);
               
       pathname: 要打开或创建的目标文件
       flags: 打开文件时，可以传入多个参数选项，用下面的一个或者多个常量进行“或”运算，构成flags
       参数:
          O_RDONLY: 只读打开
          O_WRONLY: 只写打开
          O_RDWR : 读，写打开   
       注意：这三个常量，必须指定一个且只能指定一个
          O_CREAT : 若文件不存在，则创建它。需要使用mode选项，来指明新文件的访问权限
          O_APPEND: 追加写
                                                                                      
          mode_t：如目标文件不存在，需要open创建，则第三个参数表示创建文件的默认权限,否则，使用两个参数的open
       注意：mode_t的权限设置要考虑umask的因素
                                                                                                      
       返回值：
       成功：新打开的文件描述符
       失败：-1

          
    2，文件描述符fd
       a，文件描述符的本质：数组下标
                  
       b，文件描述符的分配规则： 从最小的未被使用的下标开始分配
                              
       c，重定向的本质： 在系统底层对文件描述符开启和关闭的操作
                                      
       d，追加等这类的操作本质： 是文件打开方式的操作
                                          
    补充：Linux进程默认情况下会有3个缺省打开的文件描述符，分别是标准输入0， 标准输出1， 标准错误2
                                                      
          task_struct -> struct files_struct -> files_struct内部的 struct file* fd_array[] \
          -> struct file(里面装的是属性：name、inode等，与方法：函数指针) -> file
                                                                        
          open打开文件的本质：
          将磁盘文件加载到内存，然后创建struct file管理文件，再将struct file与进程进行关联（在数组中遍历找到\
          最小未使用的下标，将下标分配给struct file），再返回下标（文件描述符）
                                                                                              
          对Linux下一切皆文件的理解：
          实际上是使用了面向对象的思想，将硬盘、显示器等等当成不同的对象，从而进行文件的各种操作。不过Linux下用的是
          C语言，没有成员函数，用函数指针代替了成员函数
                                                                                                                        
      3，重定向
            
        a， > ：输出重定向  >> :追加重定向   < :输入重定向
                    
        b，dup2 系统调用
           int dup2(int oldfd, int newfd);
                                     
        例：4是普通文件，1是标准输出
            dup2(4,1);
            即把fd_array[]中的4数据拷贝一份到1将1覆盖，完成重定向

      4，FILE
        a，因为IO相关函数与系统调用接口对应，并且库函数封装系统调用，所以本质上，访问文件都是通过fd访问的。
                  
        b，所以C库当中的FILE结构体内部，必定封装了fd
                          
        c，C语言FILE结构体中最主要是存了两个数据，一个是缓冲区一个是文件描述符(fd)
                                  
        补充：printf等输入输出库函数会自带缓冲区（用户级缓冲区），例printf将要输入文件的数据放在缓冲区，当fclose或fflush或进程结束时
              调用write把缓冲区的数据往操作系统刷新
                                               
                                                                     
