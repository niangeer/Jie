一，冯诺依曼体系
    1，体系结构分为硬件架构与操作系统
	    硬件架构：输入、输出、存储器（内存）、CPU（运算器、控制器）
		操作系统
		
	2，硬件
	    a，内存不属于输入输出，特性为掉电易失，可认为是外设与CPU的缓存，它是计算机数据的核心
		b，存储分级：离CPU越近，存储效率越高，单价成本越高，且容量一般越小
		c，CPU为什么要通过内存与外设进行交互？
		    因为CPU效率与外设效率差太多，如果与外设直接进行交互会造成效率的降低，
			内存可进行预加载、预写入，能够提高效率
		
	3，操作系统
	    a，是什么？
		     是一款搞“管理”的软件，管理软硬件
			 硬件方面：冯诺依曼结构中的所有设备
			 软件方面：文件管理，进程管理，内存管理，驱动管理
			 
		b，怎么管理？
		     先描述，再组织
		c，为什么要管理
	         管理好软硬件为用户程序提供良好的执行环境
			 
	补充：1，缓存是快的设备给慢的设备做缓存
          2，我们现在的计算机是出于考虑成本和效率的结果，用小成本使用上效率较高的计算机，提升性价比
		  
二，系统调用和库函数概念
    1，系统调用：
	       在开发角度，操作系统对外会表现为一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分
           由操作系统提供的接口叫做系统调用
		   
	2，库函数
	       系统调用在使用上，功能比较基础，对用户的要求相对也比较高，有开发者对部分系统调用
           进行适度封装，从而形成库。库更有利于更上层用户或者开发者进行二次开发
		   
三，进程
    1，是什么？
	    可执行程序被加载进内存，变成了进程。由可执行程序与管理进程所需要的数据结构（task_struct、mm_struck）构成
	
	2，如何管理？
	    如何新建？如何调度？如何释放？如何进行其他管理？
		
	3，为什么要对进程进行管理？
	    任务需要被计算机完成，任务可能存在多个，所以有了管理的需求，先描述，再组织
		
	4，查看进程：
	    1，通过/proc  
		2，ps (ps aux | grep "mytest"  ps axj  ps -al)
		3，top
		
	补充：bash 运行原理：
	          bash：命令行解释器
		  通常是如何进行解释的呢？
		      通过创建子进程，让子进程去完成对应的任务
			  
		每一个进程都有它的时间片，长短是不固定的，由调度器去动态计算的
		
四，PCB
    1，task_struct是Linux内核的一种数据结构，它会被装载到RAM(内存)里并且包含着进程的信息
	2，内容分类
	    a，标识符：pid , ppid 
		    gitpid()，gitppid()
		
		b，状态: 任务状态(r,s,t,d,x,z)，退出代码，退出信号
		    R:运行状态（不一定在CPU上面跑，有可能在运行队列中）
			S：浅睡眠状态（可中断）
			T:停止状态
			D：深睡眠状态（不可中断）
			X:死亡状态
			Z：僵尸状态
			
	3，僵尸进程
		a，形成原因
		    父进程还存在且子进程已退出。并且父进程未读取子进程的退出状态
			
		b，为什么要存在Z进程
		    为了让父进程有时间去读取子进程的退出状态，Z状态被读取完毕后就会变为X状态，
			进而进程的PCB信息才会被操作系统释放掉
			
		c，危害
		    会造成内存资源浪费，可能造成内存泄漏，所以一定要用wait()系统调用
			
	   孤儿进程
	    a，形成原因
		    父进程退出，子进程还在运行
		
		b，孤儿进程会被1号进程领养，由1号进程进行资源回收
		
	4，程序计数器
	    a，程序计数器是用于存放下一条指令所在单元的地址的地方。
		b，当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器中，
		   此过程称为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。
		   此后经过分析指令，执行指令。完成第一条指令的执行，而后根据PC取出第二条指令的地址，
		   如此循环，执行每一条指令。
		   
	5，上下文数据
	    a，CPU在运行进程时会产生各种临时数据，这些数据叫做当前进程的上下文数据
		b，当时间片到或者有更高优先级使得进程要发生切换，切换时要进行上下文保护，
		    进程重新加载至CPU上运行时要进行上下文恢复
		
	4，fork
	    1，如何理解进程创建？
		    系统多了一个进程就要多一组管理进程的数据结构与对应的代码和数据
			
		2，为什么会有两个返回值？
		    父进程执行创建子进程的逻辑形成子进程，在执行return 之前创建好了子进程，
			父子进程之间代码共享，数据私有（表现出了进程的独立性）
			然后return是条语句，所以父子进程都要执行，又因数据私有所以有两个返回值
		
	5，优先级: 相对于其他进程的优先级
	    1，是什么？
		    使用“事务”的先后顺序
		
		2，为什么要有？
		    需要管理的对象具有多个时，需要优先级，可以改善系统性能
			
		3，怎么办？
		    决定了哪个进程优先使用某种资源（CPU、外设IO）
			
		4，查看系统进程（ps -l）
		    UID : 代表执行者的身份
			PRI ：代表这个进程可被执行的优先级，其值越小越早被执行
			NI ：代表这个进程的nice值
			
		5，NI
		    a，nice值：进程优先级的修正数值（-20~19）
			b，PRI(new)=PRI(old)+nice
			c，进入top后按“r”–>输入进程PID–>输入nice值
			
	6，补充概念
	    1，竞争性：
		    进程数多于CPU数，进程间便具有竞争属性，为了高效完成任务，更合理竞争相关资源，便具有了优先级
			
		2，独立性: 
		    多进程运行，需要独享各种资源，多进程运行期间互不干扰
			
		3，并行
		    多个进程分别在多个CPU下同时运行，叫做并行
			
		4，并发：
		    多个进程基于时间片轮转使其看起来在同时推进的状态叫做并发
			
		5，进程在时间片内，不可被抢占，为不可抢占式调度；
		   若可被抢占则为抢占式调度
		   
五，环境变量
	1，是什么？
	    系统中的某些具有一定全局属性的变量，通常是为了满足某些系统需求
		全局属性体现在可以被子进程继承下去
			
	2，为什么？
	    为了方便用户、开发者以及系统，进行某种最简单化的查找、定位、确认等问题
			
	3，环境变量是变量，具有变量名与内容
	    PATH : 指定命令的搜索路径
		HOME : 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录)
		SHELL : 当前Shell,它的值通常是/bin/bash。
			
		查看环境变量：echo $PATH
		定义环境变量：export PATH=$PATH:/hello程序所在路径
		    在命令行中定义为临时性，永久性需要去usr/目录下
		
	4，env: 显示所有环境变量
	   unset: 清除环境变量
	   set: 显示本地定义的shell变量和环境变量
		   
	5，main函数参数:   main(int argc, char* argv[], char* env[])
	    1，int argc:命令行参数个数
		2，char* argv[]:命令行参数（在C/C++中，argv[0]为可执行程序本身）
		3，char* env[]:环境变量
		    getenv:获取环境变量，用法 getenv("PATH")
			   
		例：./mytest -a -b        其中./mytest为argv[0]算第一个命令行参数
			